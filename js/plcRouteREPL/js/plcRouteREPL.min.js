const SOF="<< <",EOF=">> >",SON="<<$<",EON=">>$>";function pipe(_fn,_dest,_opts){let offset=0,l=require("Storage").read(_fn).length,interval=setInterval(()=>{if(!_dest.conn||offset>=l/*!str.length*/)return clearInterval(interval),_opts.complete&&_opts.complete(),void(_opts.end&&_dest&&_dest.end());_dest.write(require("Storage").read(_fn,offset,_opts.chunkSize)),offset+=_opts.chunkSize},50)}class ClassRouteREPL{constructor(_opts){_opts=_opts||{},this._DefConsole=eval(E.getConsole()),this._IsOn=!1,this._Name="RouteREPL",this._ReconnectTry=0,this._Port=_opts.port||23,this._Sending=!1,Object.on("complete",this.RouteOn.bind(this))}get ConsoleType(){return this._IsOn?"Telnet":E.isUSBConnected()?"USB":"NONE"}RouteOn(){try{this._Server=require("net").createServer(_socket=>{this._Socket&&this._Socket.end(),this._Socket=_socket,_socket.on("close",()=>{this._Socket=null,setTimeout(()=>{this._Socket||this.RouteOff()},50)}),_socket.pipe(LoopbackB),LoopbackB.pipe(this._Socket),E.setConsole(LoopbackA,{force:!1})}),this._Server.listen(this._Port)}catch(e){H.Logger.Service.Log({service:"RouteREPL",level:"I",msg:e}),++this._ReconnectTry<3?this.RouteOn():(this.RouteOff(),this._ReconnectTry=0)}this._IsOn=!0}Receive(_stdin){LoopbackB.write(_stdin)}isREPLConnected(_flag){let func=USB.isConnected||E.isUSBConnected||(()=>!1);return Boolean(this._IsOn||func())}UploadFile(_fileName,_fileSize){if(!this._Sending)return new Promise((res,rej)=>{E.setConsole(null);let offset=0;this._Socket.removeAllListeners("data");let socketHandler=_data=>{let sof=_data.indexOf(SOF),eof=_data.indexOf(EOF);_data=_data.slice(-1!=sof?sof+SOF.length:0,-1==eof?_data.length:eof),require("Storage").write(_fileName,_data,offset,_fileSize),eof>-1&&(this._Socket.removeListener("data",socketHandler),E.setConsole(LoopbackA),H.Logger.Service.Log({service:"Repl",level:"I",msg:`Uploaded new file over TCP: ${_fileName} with ${_fileName} bytes `}),res()),offset+=_data.length};this._Socket.prependListener("data",socketHandler)})}RouteOff(){E.setConsole(this._DefConsole,{force:!0}),this._Socket&&this._Socket.end(),this._IsOn=!1}GetFileList(){return require("Storage").list(void 0,{sf:!1})}SendFileList(){E.setConsole(null),this._Socket.write(`${SOF}${this.GetFileList().join(", ")}${EOF}`),setTimeout(()=>{this.RouteOff()},250)}SendFiles(_args){if("*"==_args&&(_args=this.GetFileList().filter(_fn=>"plcRouteREPL.min.js"!=_fn)),Array.isArray(_args)&&_args.length>0)return _args.reduce((promiseChain,fileName)=>promiseChain.then(()=>this.SendFile(fileName)),Promise.resolve()).then(this.RouteOff)}SendFile(_fileName){return new Promise((res,rej)=>{let file;this._Socket||rej(),E.setConsole(null),this._Socket.removeAllListeners("data");try{if(file=require("Storage").read(_fileName),!file)throw new Error(`Failed to read ${_fileName}`)}catch(e){return H.Logger.Service.Log({service:this._Name,level:"E",msg:`Error while sending ${_fileName} file via TCP: ${e.message}`}),void rej()}this._Sending=!0,setTimeout(()=>{this._Socket.write(`${SON}${JSON.stringify({fn:_fileName})}${EON}`),this._Socket.write(SOF),E.pipe(file,this._Socket,{end:!1,chunkSize:64,complete:()=>{this._Socket.write(EOF),this._Sending=!1,setTimeout(res,500)}})},250)})}}exports=ClassRouteREPL;